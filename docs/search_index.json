[
["1-nlsy-example.html", "ITEMS: Longitudinal Data Analysis Part 1 NLSY Example", " ITEMS: Longitudinal Data Analysis Tessa L. Johnson 2020-07-12 Part 1 NLSY Example In this example, we will be using data from the National Longitudinal Survey of Youth (NLSY). The current subset of data comes from assessments administered to mother-child pairs starting in 1986. Data were restricted to children ages 6-8 with complete data at the first wave of measurement. Data were retained from only one child per mother. More information about the example data can be found here: Curran, P. J. (1997). Comparing three modern approaches to longitudinal data analysis: An examination of a single developmental sample. In Symposium conducted at the meeting of the Society for Research on child Development, Washington, DC. "],
["2-getting-started.html", "Part 2 Getting Started", " Part 2 Getting Started In this worked example, we will follow the guidelines presented in the ITEMS Longitudinal Data Analysis module. The basic structure of this guided example is as follows: Loading and manipulating data Performing exploratory data analysis Conducting mixed-effects modeling using nlme::lme Graphically evaluating modeling assumptions Throughout these sections, we present example code for producing display-quality tables and plots for different components of the longitudinal data analysis. While there are several examples in this guide, there are even more ways to examine and present longitudinal data. The documentation for ggplot2 and gt are great places to go for questions about producing plots and tables, respectively, and the documentation for the nlme package is the main resource for questions mixed effects model code. In addition, interested readers will find many helpful examples in Pinhero &amp; Bates (2000): Pinheiro, J., &amp; Bates, D. (2006). Mixed-effects models in S and S-PLUS. Springer Science &amp; Business Media. "],
["2-1-load-data.html", "2.1 Load Data", " 2.1 Load Data To load the data, we use the readr::read_csv function. The na = &quot;-99&quot; statement tells readr how to recode missing data. During this step, there are a few variables we would like to rename to facilitate pivoting (converting from wide format to long format) later on, so we write a renaming function (insert_underscore). The renaming function inserts a &quot;_&quot; character after the initial set of alphabet characters in the original column name but before any non-alphabet characters. The variables we will rename include: ag(1-4) = age at each wave; an(1-4) = anti-social behavior score at each wave; and r(1-4) = reading score at each wave. Last, we convert the variable “gen” (child’s assigned sex) to a factor variable with the following levels: 0 = “female” and 1 = “male”. ##--TUTORIAL DATASETS--## # read data path_dat &lt;- system.file( &quot;extdata&quot;, &quot;anti-read.csv&quot;, package = &quot;ITEMSlme&quot;, mustWork = TRUE ) # renaming function insert_underscore &lt;- function(names){ sub(&quot;^([[:alpha:]]+)&quot;, &quot;\\\\1_&quot;, names) } # read in the data with readr::read_csv dat_wide &lt;- path_dat %&gt;% readr::read_csv(., na = &quot;-99&quot;, col_types = readr::cols()) %&gt;% dplyr::rename_with( insert_underscore, dplyr::starts_with(c(&quot;ag&quot;, &quot;an&quot;, &quot;r&quot;)) ) %&gt;% dplyr::mutate( gen = forcats::fct_recode(as.factor(gen), female = &quot;0&quot;, male = &quot;1&quot;) ) %&gt;% print(.) ## # A tibble: 405 x 17 ## id gen momage homecog homeemo an_1 an_2 an_3 an_4 r_1 r_2 r_3 ## &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 male 27 7 11 1 0 1 0 27 49 50 ## 2 2 male 27 10 7 1 1 0 1 31 47 56 ## 3 3 fema~ 27 7 7 5 0 5 3 36 52 60 ## 4 4 male 24 8 8 1 1 NA NA 18 30 NA ## 5 5 male 26 8 8 2 3 3 1 23 49 NA ## 6 6 fema~ 25 6 11 1 0 0 0 21 NA 45 ## 7 7 fema~ 22 5 5 3 NA 0 10 21 NA 48 ## 8 8 fema~ 23 1 4 0 NA 0 4 13 NA 37 ## 9 9 fema~ 24 3 7 5 3 2 0 29 NA 35 ## 10 10 fema~ 28 9 11 2 3 6 5 45 58 76 ## # ... with 395 more rows, and 5 more variables: r_4 &lt;dbl&gt;, ag_1 &lt;dbl&gt;, ## # ag_2 &lt;dbl&gt;, ag_3 &lt;dbl&gt;, ag_4 &lt;dbl&gt; "],
["2-2-wide-to-long.html", "2.2 Wide to Long", " 2.2 Wide to Long Because we have 3 repeated measures variables (“ag”, “an” and “r”), we use the “names_pattern” argument of tidyr::pivot_longer. “names_pattern” uses a regular expression &quot;(.+)_(.+)&quot; in combo with the “names_to” argument c(“.value”, “wave”) to save all of the data from each repeated measures variable under the names “an”, “r”, and “ag”. The new “wave” variable contains information about when each measurement was taken, drawing its values from the number at the end of the original column name. For example, all of the data from the original column “an_2” will be stored in the new “an” variable with a “wave” code of “2”. Because there are 4 waves of measurement, there will now be 4 rows for each person with complete data (n.b., children with missing data will have fewer rows), which you can double check by looking at the “id” column. In the dplyr::mutate step, we subtract 1 from each value of “wave” because we want our initial measurement to be coded “0”. This will have implications for the interpretation of the intercept when we move to the modeling phase. Finally, we rename all our variables to something more informative. This step isn’t strictly necessary, but often it is useful for revisiting and collaborating on code to use informative variable names. # pivot wide to long dat_long &lt;- dat_wide %&gt;% tidyr::pivot_longer( cols = c(dplyr::contains(&quot;_&quot;)), names_to = c(&quot;.value&quot;, &quot;wave&quot;), names_pattern = c(&quot;(.+)_(.+)&quot;) ) %&gt;% dplyr::mutate(., wave = as.numeric(wave) - 1) %&gt;% dplyr::rename( person_id = id, assigned_sex = gen, mom_age = momage, home_cog = homecog, home_emo = homeemo, anti_score = an, read_score = r, child_age = ag ) %&gt;% print(.) ## # A tibble: 1,620 x 9 ## person_id assigned_sex mom_age home_cog home_emo wave anti_score read_score ## &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 male 27 7 11 0 1 27 ## 2 1 male 27 7 11 1 0 49 ## 3 1 male 27 7 11 2 1 50 ## 4 1 male 27 7 11 3 0 NA ## 5 2 male 27 10 7 0 1 31 ## 6 2 male 27 10 7 1 1 47 ## 7 2 male 27 10 7 2 0 56 ## 8 2 male 27 10 7 3 1 64 ## 9 3 female 27 7 7 0 5 36 ## 10 3 female 27 7 7 1 0 52 ## # ... with 1,610 more rows, and 1 more variable: child_age &lt;dbl&gt; "],
["3-exploratory-data-analysis.html", "Part 3 Exploratory Data Analysis", " Part 3 Exploratory Data Analysis We choose age here rather than wave because children were all different ages at the first wave of measurement and waves were not completed at the exact same time for each child (meaning that some children were measured every 2 years, while others were measured at wave 1, then 3 years later for wave 2, then 2 years later for wave 3, etc.). Anti-social behavior trajectory may have a developmental component that would get masked if we looked across waves rather than age. During this section, we showcase both the dplyr::group_by and dplyr::summarize functions, which help us calculate descriptive statistics for each level of child_age. Then, we demonstrate the gt package, used for producing display-quality tables of results. "],
["3-1-missingness.html", "3.1 Missingness", " 3.1 Missingness Like many longitudinal datasets, the data used in this example contain missingness. When using mixed-effects models, it is important to understand where and how missing observations appear. As we learned in Getting Started, the current data were restricted to children with complete data at the first wave only, though children could appear in the dataset if they were missing data on the second, third, or fourth wave of data collection. To better understand missing data on the outcome, anti-social behavior, we provide examples of four different visualization plots. 3.1.1 Missing Data Setup Because we plan to analyze our data by age and not wave, let’s first get a sense of how many anti-social scores are missing at each age level. We know that children were measured up to four times each, but children ranged from ages 6 - 15 in the dataset. Even though we don’t have an anti-social behavior score for each child at each age (6, 7, 8, 9, 10…), we know that theoretically each child could have contributed an anti-social behavior score at each age. Using the pivot functions from the tidyr package, we can identify missing data at each age for each child: dat_miss &lt;- dat_long %&gt;% dplyr::select(., person_id, child_age, anti_score) %&gt;% dplyr::filter(., !is.na(child_age)) %&gt;% tidyr::pivot_wider( names_from = &quot;child_age&quot;, values_from = c(&quot;anti_score&quot;) ) %&gt;% tidyr::pivot_longer( cols = -person_id, names_to = &quot;child_age&quot;, values_to = &quot;anti_score&quot; ) %&gt;% dplyr::mutate( child_age = as.numeric(child_age), anti_miss = dplyr::if_else(is.na(anti_score), 1, 0) ) %&gt;% dplyr::left_join(., dat_long) %&gt;% dplyr::select(., person_id, child_age, wave, anti_score, anti_miss) %&gt;% dplyr::mutate(., fill_pal = dplyr::case_when( !is.na(wave) ~ wave, TRUE ~ 4 )) %&gt;% dplyr::arrange(., anti_miss, child_age, person_id) %&gt;% print(.) ## Joining, by = c(&quot;person_id&quot;, &quot;child_age&quot;, &quot;anti_score&quot;) ## # A tibble: 4,050 x 6 ## person_id child_age wave anti_score anti_miss fill_pal ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 6 0 1 0 0 ## 2 5 6 0 2 0 0 ## 3 6 6 0 1 0 0 ## 4 8 6 0 0 0 0 ## 5 11 6 0 1 0 0 ## 6 14 6 0 2 0 0 ## 7 17 6 0 2 0 0 ## 8 23 6 0 0 0 0 ## 9 26 6 0 1 0 0 ## 10 29 6 0 1 0 0 ## # ... with 4,040 more rows 3.1.2 Lollipop Plot If children were measured 4 times over 10 possible ages, we could reasonably expect to be missing anti-social behavior scores at a rate of 60% in each age group, assuming that missingness were distributed uniformly and that children were all measured at evenly spaced intervals. Let’s explore this assumption using what is known as a “lollipop plot”. We include a horizontal dashed line to indicate the 60% threshold. We can also use this plot to highlight places where missingness is much higher (or lower) than what we expect using colors and labels. In plotting, we find that at age 15, about 98% of possible anti-social behavior scores are missing, suggesting that most children didn’t reach age 15 by the end of the study. # helper for axis limits age_lim &lt;- c(min(dat_long$child_age, na.rm = TRUE), max(dat_long$child_age, na.rm = TRUE)) # adjust dat_miss for lollipop plot dat_lollipop &lt;- dat_miss %&gt;% dplyr::group_by(., child_age) %&gt;% dplyr::summarise( pct_miss = mean(anti_miss, na.rm = TRUE) * 100 ) ## `summarise()` ungrouping output (override with `.groups` argument) # plot dat_lollipop %&gt;% ggplot2::ggplot( ggplot2::aes(x = child_age, y = pct_miss) ) + ggplot2::geom_segment( ggplot2::aes(x = child_age, xend = child_age, y = 0, yend = pct_miss), color = dplyr::if_else( dat_lollipop$pct_miss &gt; 95, viridis::plasma(n = 4, end = 0.75)[4], &quot;gray25&quot; ), size = dplyr::if_else(dat_lollipop$pct_miss &gt; 95, 1.3, 0.7) ) + ggplot2::geom_point( color = dplyr::if_else( dat_lollipop$pct_miss &gt; 95, viridis::plasma(n = 4, end = 0.75)[4], &quot;gray25&quot; ), size = dplyr::if_else(dat_lollipop$pct_miss &gt; 95, 5, 2) ) + ggplot2::geom_text( ggplot2::aes( x = child_age - 0.5, y = pct_miss - 5, label = paste0(round(pct_miss, 1), &quot;%&quot;) ), data = dat_lollipop %&gt;% dplyr::filter(pct_miss &gt; 95), vjust = 1, hjust = 0.5 ) + ggplot2::geom_curve( ggplot2::aes( x = child_age - 0.5, y = pct_miss - 5, xend = child_age, yend = pct_miss), data = dat_lollipop %&gt;% dplyr::filter(pct_miss &gt; 95), arrow = ggplot2::arrow(length = ggplot2::unit(0.03, &quot;npc&quot;)), curvature = -0.5 ) + ggplot2::geom_hline(yintercept = 60, color = &quot;gray50&quot;, linetype = &quot;dashed&quot;) + ggplot2::scale_x_continuous( limits = c(age_lim[1] - .5, age_lim[2] + .5), breaks = seq(age_lim[1], age_lim[2], 1) ) + ggplot2::theme( legend.position = &quot;none&quot; ) + ggplot2::xlab(&quot;Child Age&quot;) + ggplot2::ylab(&quot;Percent Missing&quot;) + ggplot2::ggtitle(&quot;Percent of Children Missing Anti-Social Scores by Age&quot;) 3.1.3 Bar Plot by Pattern Another helpful way to examine missingness in longitudinal data is to look at the patterns of missingness. We can think about this like within-person attrition. In other words, for each person, we calculate the percent of measurement waves they participated in out of the possible 4. There are four possible options in our situation (we ignore order to keep the example simple): anti-social data are present for each of the four waves, anti-social data are present for 3 of the four waves (we ignore order, but you could differentiate between individuals who have data for Waves 1, 2, and 3 and individuals who have data for Waves 1, 3, and 4), anti-social data are present for 2 of the four waves (again, we ignore order), and anti-social data are present for 1 wave only (in our case, due to the way our sample was defined, we know that people with only 1 wave of data contributed to the first wave). dat_attrit_l &lt;- dat_miss %&gt;% dplyr::group_by(., person_id) %&gt;% dplyr::summarise( total_waves = sum(1 - anti_miss) ) %&gt;% dplyr::group_by(., total_waves) %&gt;% dplyr::summarise( ct_waves = dplyr::n(), pct_waves = dplyr::n() / NROW(dat_wide) ) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) dat_attrit_l %&gt;% ggplot2::ggplot(.) + ggplot2::aes( x = forcats::fct_reorder(as.factor(total_waves), dplyr::desc(total_waves)), y = pct_waves * 100, fill = as.factor(total_waves) ) + ggplot2::geom_bar(stat = &quot;identity&quot;) + ggplot2::geom_text( ggplot2::aes( y = pct_waves * 100 + 5, label = round(pct_waves * 100, 1) ), size = 3.5 ) + ggplot2::scale_x_discrete( labels = c(&quot;4&quot; = &quot;Exactly 4 Waves (All)&quot;, &quot;3&quot; = &quot;Exactly 3 Waves (Any)&quot;, &quot;2&quot; = &quot;Exactly 2 Waves (Any)&quot;, &quot;1&quot; = &quot;Exactly 1 Wave (1st)&quot;) ) + ggplot2::scale_fill_viridis_d(end = 0.75, option = &quot;C&quot;) + ggplot2::theme( legend.position = &quot;none&quot;, axis.text.x = ggplot2::element_text( angle = 45, hjust = 1, margin = ggplot2::margin(t = 0, r = 0, b = 10, l = 0) ), axis.text.y = ggplot2::element_text( margin = ggplot2::margin(t = 0, r = 0, b = 0, l = 10) ) ) + ggplot2::ylim(0, 100) + ggplot2::xlab(&quot;Number of Data Collection Waves Completed&quot;) + ggplot2::ylab(&quot;Percent of Children \\n per Attrition Category&quot;) + ggplot2::ggtitle( expression( paste(&quot;Attrition Patterns of Anti-Social Behavior Scores &quot;, &quot;(&quot;, n[&quot;Wave 1&quot;], &quot; = 405)&quot;) ) ) 3.1.4 Bar Plot by Wave In this next bar plot example, we display across-person attrition. Here, we are merely interested in what percent of our sample (n = 405) contributed anti-social data at each wave. dat_attrit_c &lt;- dat_miss %&gt;% dplyr::filter(., !is.na(wave)) %&gt;% dplyr::group_by(., wave) %&gt;% dplyr::summarise( total_obs = sum(1 - anti_miss), pct_obs = sum(1 - anti_miss) / NROW(dat_wide) ) ## `summarise()` ungrouping output (override with `.groups` argument) dat_attrit_c %&gt;% ggplot2::ggplot(.) + ggplot2::aes( x = as.factor(wave), y = pct_obs * 100, fill = as.factor(total_obs) ) + ggplot2::geom_bar( stat = &quot;identity&quot; ) + ggplot2::geom_text( ggplot2::aes( y = pct_obs * 100 + 5, label = round(pct_obs * 100, 1) ), position = ggplot2::position_dodge(width = 0.9), size = 3.5 ) + ggplot2::scale_x_discrete( labels = c(&quot;0&quot; = &quot;Wave 1&quot;, &quot;1&quot; = &quot;Wave 2&quot;, &quot;2&quot; = &quot;Wave 3&quot;, &quot;3&quot; = &quot;Wave 4&quot;) ) + ggplot2::scale_fill_viridis_d(end = 0.75, option = &quot;C&quot;) + ggplot2::theme( legend.position = &quot;none&quot;, axis.text.x = ggplot2::element_text( angle = 45, hjust = 1, margin = ggplot2::margin(t = 0, r = 0, b = 10, l = 0) ), axis.text.y = ggplot2::element_text( margin = ggplot2::margin(t = 0, r = 0, b = 0, l = 10) ) ) + ggplot2::xlab(&quot;Measurement Wave&quot;) + ggplot2::ylab(&quot;Percent of Children \\n Responding within Each Wave&quot;) + ggplot2::ggtitle( expression( paste(&quot;Anti-Social Behavior Score Reporting Rates &quot;, &quot;(&quot;, n[&quot;Wave 1&quot;], &quot; = 405)&quot;) ) ) 3.1.5 Raster Plot This last missingness plot example is called a “raster plot”. Whereas the previous plots provided an aggregated glimpse of missing data in our dataset, the raster plot displays the missingness for each individual in our data. Using color to indicate the measurement wave and carefully ordering the data in the plot, we can make sense of a large amount of data all at once. dat_miss %&gt;% ggplot2::ggplot(.) + ggplot2::aes( x = child_age, y = forcats::fct_inorder(as.factor(person_id)), fill = as.factor(fill_pal) ) + ggplot2::geom_raster(hjust = 0.5, vjust = 0.5) + ggplot2::scale_x_continuous( limits = c(age_lim[1] - .5, age_lim[2] + .5), breaks = seq(age_lim[1], age_lim[2], 1) ) + ggplot2::scale_fill_manual( name = &quot;Wave&quot;, labels = c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;Missing Score&quot;), values = c(viridis::viridis(4, option = &quot;C&quot;, end = 0.75), &quot;grey90&quot;) ) + ggplot2::theme( panel.background = ggplot2::element_blank(), panel.grid.minor = ggplot2::element_blank(), panel.grid.major = ggplot2::element_blank(), axis.text.x = ggplot2::element_blank(), axis.ticks.x = ggplot2::element_blank(), legend.position = &quot;bottom&quot; ) + ggplot2::labs( x = &quot;Child Age&quot;, y = &quot;Child ID&quot;, title = &quot;Missing Anti-Social Scores by Age and Wave&quot; ) + ggplot2::coord_flip() 3.1.6 Updated Dataset In the step above, we learned that very few children were measured at age 15 (in fact, only 8 children were measured at age 15). For the purposes of this guided example, we will remove those 8 children from the analytic dataset to avoid estimation and convergence issues in modeling later on. NOTE: There are better ways to deal with small sample sizes, but those methods are outside the scope of this module. We do not generally recommend deleting observations! # find ids for children who are 15 at wave 4 remove_id &lt;- dat_long %&gt;% dplyr::filter(., child_age == 15) %&gt;% dplyr::select(., person_id) %&gt;% unlist(.) # remove ids identified in remove_id dat_final &lt;- dat_long %&gt;% dplyr::filter(., !(person_id %in% remove_id)) # check new sample size dat_final %&gt;% dplyr::distinct(., person_id) %&gt;% NROW(.) ## [1] 397 "],
["3-2-univariate-descriptives.html", "3.2 Univariate Descriptives", " 3.2 Univariate Descriptives Following our exploration of missing data, we proceed to calculate univariate descriptive statistics. Given what we learned about the distribution of data across age groups in the missing data section, let’s move forward using the dat_final dataset created in Updated Dataset. 3.2.1 Univariate Setup Using the dat_final long dataset, it is fairly straightforward to calculate the means, variances, and number of observations of the anti-social behavior scores within each age. Knowing the means and variances within each age group can help us see whether and how anti-social behavior changes on average over time. In addition, understanding whether the variances are changing over time can help us make modeling decisions later on. Recall that our new sample size is 397, following the steps in [Updated Data]. Each child was measured up to four times (and we retained a row even when missing their anti-social behavior information), so summing the n, or number of observations, should yield 397 * 4 = 1588. Note that 249 observations have a child age listed as NA. This number tells us how many anti-social behavior scores were not recorded across all measurement waves and individuals. For more information on how the missing anti-social behavior scores are distributed across individuals, see Raster Plot. # calculate descriptive statistics for each level of child&#39;s age moment_tab &lt;- dat_final %&gt;% dplyr::group_by(., child_age) %&gt;% dplyr::summarize( n = dplyr::n(), mean = round(mean(anti_score, na.rm = TRUE), 2), variance = round(var(anti_score, na.rm = TRUE), 2)) %&gt;% dplyr::mutate(., child_age = dplyr::case_when( is.na(child_age) ~ &quot;Missing&quot;, TRUE ~ as.character(child_age) )) %&gt;% print(.) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 10 x 4 ## child_age n mean variance ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 6 122 1.57 2.78 ## 2 7 168 1.55 2.42 ## 3 8 138 2.04 3.26 ## 4 9 192 1.89 3.82 ## 5 10 149 2.15 4.59 ## 6 11 169 1.79 3.81 ## 7 12 131 1.84 3.07 ## 8 13 169 2.25 5.19 ## 9 14 101 1.96 4.36 ## 10 Missing 249 NaN NA 3.2.2 Univariate Table Now that we’ve calculated our univariate descriptive statistics, we will use the gt package to create a display-quality table of results. The gt package has a similar ethos to ggplot2, where each component of a table can be added on to the previous component. Although the intricacies of both gt and ggplot2 are beyond the scope of this module, we thought it was important to demonstrate ways to create reproducible tables and plots for longitudinal data. gt_moments &lt;- moment_tab %&gt;% gt::gt(.) %&gt;% gt::tab_header( data = ., title = &quot;Univariate Descriptive Statistics for Anti-Social Behavior Scores&quot;, subtitle = &quot;Means, variances, &amp; number of observations within each age.&quot; ) %&gt;% gt::tab_spanner( data = ., label = &quot;Summary of Anti-Social Scores by Age&quot;, columns = c(&quot;n&quot;, &quot;mean&quot;, &quot;variance&quot;) ) %&gt;% gt::cols_label( child_age = &quot;Child Age&quot;, n = &quot;Num. Obs.&quot;, mean = &quot;Mean&quot;, variance = &quot;Variance&quot; ) %&gt;% gt::tab_options(., row.striping.include_table_body = FALSE) %&gt;% gt::tab_style( data = ., style = gt::cell_borders( sides = c(&quot;top&quot;, &quot;bottom&quot;), color = &quot;#ffffff&quot;, weight = gt::px(0), style = &quot;solid&quot; ), locations = gt::cells_body( columns = dplyr::everything(), rows = dplyr::everything()) ) %&gt;% gt::cols_align(., align = &quot;center&quot;, columns = TRUE) %&gt;% gt::fmt_missing(., columns = c(&quot;n&quot;, &quot;mean&quot;, &quot;variance&quot;)) # print plot gt_moments html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #uvfeqxphib .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #uvfeqxphib .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #uvfeqxphib .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #uvfeqxphib .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #uvfeqxphib .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #uvfeqxphib .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #uvfeqxphib .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #uvfeqxphib .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #uvfeqxphib .gt_column_spanner_outer:first-child { padding-left: 0; } #uvfeqxphib .gt_column_spanner_outer:last-child { padding-right: 0; } #uvfeqxphib .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #uvfeqxphib .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #uvfeqxphib .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #uvfeqxphib .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #uvfeqxphib .gt_from_md > :first-child { margin-top: 0; } #uvfeqxphib .gt_from_md > :last-child { margin-bottom: 0; } #uvfeqxphib .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #uvfeqxphib .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #uvfeqxphib .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #uvfeqxphib .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #uvfeqxphib .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #uvfeqxphib .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #uvfeqxphib .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #uvfeqxphib .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #uvfeqxphib .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #uvfeqxphib .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #uvfeqxphib .gt_sourcenote { font-size: 90%; padding: 4px; } #uvfeqxphib .gt_left { text-align: left; } #uvfeqxphib .gt_center { text-align: center; } #uvfeqxphib .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #uvfeqxphib .gt_font_normal { font-weight: normal; } #uvfeqxphib .gt_font_bold { font-weight: bold; } #uvfeqxphib .gt_font_italic { font-style: italic; } #uvfeqxphib .gt_super { font-size: 65%; } #uvfeqxphib .gt_footnote_marks { font-style: italic; font-size: 65%; } Univariate Descriptive Statistics for Anti-Social Behavior Scores Means, variances, &amp; number of observations within each age. Child Age Summary of Anti-Social Scores by Age Num. Obs. Mean Variance 6 122 1.57 2.78 7 168 1.55 2.42 8 138 2.04 3.26 9 192 1.89 3.82 10 149 2.15 4.59 11 169 1.79 3.81 12 131 1.84 3.07 13 169 2.25 5.19 14 101 1.96 4.36 Missing 249 &mdash; &mdash; "],
["3-3-bivariate-descriptives.html", "3.3 Bivariate Descriptives", " 3.3 Bivariate Descriptives One limitation of long-format data is in calculating bivariate descriptive statistics like correlations and covariances. Tidyverse makes converting from long to wide and back fairly simple. To demonstrate, we take our long-format data and convert back to wide in order to calculate the correlation of anti-social behavior scores measured at different ages. These statistics can help us identify possible error covariance structures for our data, important for modeling later on. Missing data note: Because children were measured generally every 2-3 years, each child will have “missing” data for their anti-social behavior score at ages when they weren’t measured (in addition to non-response and other missing data mechanisms). Due to this structure, we treated missing data in the correlation matrix using pairwise complete observations. Missing data treatments like imputation are out of the scope of this module, but suffice it to say that there is a wealth of literature on missing data in longitudinal studies to help guide you. 3.3.1 Bivariate Setup Using the pivot_wider function like we did in Univariate Setup, we can create a wide-format dataset with a column for each unique child age (e.g., 6, 7, 8, 9, …). Then, calculating the correlation matrix proceeds in a straightforward manner. As with calculating the variances by age in Univariate Setup, calculating the anti-social score correlations by age can help inform us about various modeling choices later. cor_tab &lt;- dat_final %&gt;% dplyr::select(., person_id, child_age, anti_score) %&gt;% dplyr::filter(., !is.na(child_age)) %&gt;% dplyr::arrange(., child_age, person_id) %&gt;% tidyr::pivot_wider( names_from = &quot;child_age&quot;, values_from = c(&quot;anti_score&quot;)) %&gt;% dplyr::select(., -person_id) %&gt;% corrr::correlate(., diagonal = 1, use = &quot;pairwise&quot;, quiet = TRUE) %&gt;% dplyr::mutate(., child_age = as.numeric(rowname), .before = rowname) %&gt;% dplyr::select(., -rowname) %&gt;% purrr::map_df(., ~format(round(.x, 2), nsmall = 2)) %&gt;% print(.) ## Warning in stats::cor(x = x, y = y, use = use, method = method): the standard ## deviation is zero ## # A tibble: 9 x 10 ## child_age `6` `7` `8` `9` `10` `11` `12` `13` `14` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 &quot; 6.00&quot; &quot;1.00&quot; &quot; NA&quot; &quot;0.49&quot; &quot;0.31&quot; &quot;0.57&quot; &quot; 0.30&quot; &quot; 0.09&quot; 0.50 &quot; NA&quot; ## 2 &quot; 7.00&quot; &quot; NA&quot; &quot;1.00&quot; &quot; NA&quot; &quot;0.51&quot; &quot;0.34&quot; &quot; 0.53&quot; &quot; 0.39&quot; 0.38 &quot;0.59&quot; ## 3 &quot; 8.00&quot; &quot;0.49&quot; &quot; NA&quot; &quot;1.00&quot; &quot; NA&quot; &quot;0.56&quot; &quot; 0.27&quot; &quot; 0.44&quot; 0.82 &quot;0.44&quot; ## 4 &quot; 9.00&quot; &quot;0.31&quot; &quot;0.51&quot; &quot; NA&quot; &quot;1.00&quot; &quot;0.87&quot; &quot; 0.55&quot; &quot; 0.57&quot; 0.58 &quot;0.00&quot; ## 5 &quot;10.00&quot; &quot;0.57&quot; &quot;0.34&quot; &quot;0.56&quot; &quot;0.87&quot; &quot;1.00&quot; &quot; NA&quot; &quot; 0.56&quot; 0.73 &quot;0.55&quot; ## 6 &quot;11.00&quot; &quot;0.30&quot; &quot;0.53&quot; &quot;0.27&quot; &quot;0.55&quot; &quot; NA&quot; &quot; 1.00&quot; &quot;-0.15&quot; 0.60 &quot; NA&quot; ## 7 &quot;12.00&quot; &quot;0.09&quot; &quot;0.39&quot; &quot;0.44&quot; &quot;0.57&quot; &quot;0.56&quot; &quot;-0.15&quot; &quot; 1.00&quot; 0.65 &quot;0.47&quot; ## 8 &quot;13.00&quot; &quot;0.50&quot; &quot;0.38&quot; &quot;0.82&quot; &quot;0.58&quot; &quot;0.73&quot; &quot; 0.60&quot; &quot; 0.65&quot; 1.00 &quot;0.84&quot; ## 9 &quot;14.00&quot; &quot; NA&quot; &quot;0.59&quot; &quot;0.44&quot; &quot;0.00&quot; &quot;0.55&quot; &quot; NA&quot; &quot; 0.47&quot; 0.84 &quot;1.00&quot; 3.3.2 Bivariate Table With a few small tweaks to the raw correlation matrix produced above, we can now use the gt package as before to produce a display-quality correlation table. Note that the “—” symbol blocks off the upper triangle of the correlation matrix to reduce visual redundancy, and “NA” symbols within the lower triangle indicate correlations that could not be calculated due to missing data (for example, the correlation for anti-social behavior at age 6 and age 14 is missing because no children were measured at both age 6 and 14). # table results cor_tab_upper &lt;- cor_tab %&gt;% dplyr::select(., -child_age) cor_tab_upper[upper.tri(cor_tab_upper, diag = FALSE)] &lt;- NA gt_cor_tab &lt;- cor_tab_upper %&gt;% dplyr::mutate(., child_age = 6:14, .before = &quot;6&quot;) %&gt;% gt::gt(.) %&gt;% gt::tab_header( data = ., title = &quot;Correlation of Anti-Social Scores Across Age&quot;, subtitle = &quot;Complete pairwise observations were retained.&quot; ) %&gt;% gt::tab_spanner( data = ., label = &quot;Self-Correlated Scores by Age&quot;, columns = tidyselect::matches(&quot;\\\\d&quot;) ) %&gt;% gt::cols_label(., child_age = &quot;Child Age&quot;) %&gt;% gt::fmt_missing(., columns = tidyselect::matches(&quot;\\\\d&quot;)) %&gt;% gt::tab_options(., row.striping.include_table_body = FALSE) %&gt;% gt::tab_style( data = ., style = gt::cell_borders( sides = c(&quot;top&quot;, &quot;bottom&quot;), color = &quot;#ffffff&quot;, weight = gt::px(0), style = &quot;solid&quot; ), locations = gt::cells_body( columns = dplyr::everything(), rows = dplyr::everything() ) ) %&gt;% gt::cols_align(., align = &quot;center&quot;, columns = TRUE) # print plot gt_cor_tab html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #oulerdslti .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #oulerdslti .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #oulerdslti .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #oulerdslti .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #oulerdslti .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #oulerdslti .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #oulerdslti .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #oulerdslti .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #oulerdslti .gt_column_spanner_outer:first-child { padding-left: 0; } #oulerdslti .gt_column_spanner_outer:last-child { padding-right: 0; } #oulerdslti .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #oulerdslti .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #oulerdslti .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #oulerdslti .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #oulerdslti .gt_from_md > :first-child { margin-top: 0; } #oulerdslti .gt_from_md > :last-child { margin-bottom: 0; } #oulerdslti .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #oulerdslti .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #oulerdslti .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #oulerdslti .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #oulerdslti .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #oulerdslti .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #oulerdslti .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #oulerdslti .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #oulerdslti .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #oulerdslti .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #oulerdslti .gt_sourcenote { font-size: 90%; padding: 4px; } #oulerdslti .gt_left { text-align: left; } #oulerdslti .gt_center { text-align: center; } #oulerdslti .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #oulerdslti .gt_font_normal { font-weight: normal; } #oulerdslti .gt_font_bold { font-weight: bold; } #oulerdslti .gt_font_italic { font-style: italic; } #oulerdslti .gt_super { font-size: 65%; } #oulerdslti .gt_footnote_marks { font-style: italic; font-size: 65%; } Correlation of Anti-Social Scores Across Age Complete pairwise observations were retained. Child Age Self-Correlated Scores by Age 6 7 8 9 10 11 12 13 14 6 1.00 &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; 7 NA 1.00 &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; 8 0.49 NA 1.00 &mdash; &mdash; &mdash; &mdash; &mdash; &mdash; 9 0.31 0.51 NA 1.00 &mdash; &mdash; &mdash; &mdash; &mdash; 10 0.57 0.34 0.56 0.87 1.00 &mdash; &mdash; &mdash; &mdash; 11 0.30 0.53 0.27 0.55 NA 1.00 &mdash; &mdash; &mdash; 12 0.09 0.39 0.44 0.57 0.56 -0.15 1.00 &mdash; &mdash; 13 0.50 0.38 0.82 0.58 0.73 0.60 0.65 1.00 &mdash; 14 NA 0.59 0.44 0.00 0.55 NA 0.47 0.84 1.00 "],
["3-4-trajectories.html", "3.4 Trajectories", " 3.4 Trajectories In this section, we demonstrate two different ways to visualize longitudinal trajectories, or the changes in anti-social behavior score over time. Trajectory plots are very useful in conducting exploratory data analyses because they help us understand the functional form of the outcome. In other words, we can generally spot linearity and non-linearity in a plot. It is also important to plot both the aggregated and disaggregated change over time because the trajectory of the whole sample may not be the same as the trajectory for each individual. 3.4.1 Aggregated Plot First, we plot the aggregated means overlaid on individual plotted points of anti-social behavior by child’s age. The plot is broken up into two frames based on child’s assigned sex, and a linear curve is fitted to each trajectory. dat_final %&gt;% dplyr::group_by(., child_age, assigned_sex) %&gt;% dplyr::mutate(., mean = mean(anti_score, na.rm = TRUE)) %&gt;% dplyr::ungroup(.) %&gt;% ggplot2::ggplot(.) + ggplot2::aes(y = mean, x = child_age, color = assigned_sex) + ggplot2::geom_jitter( ggplot2::aes(y = anti_score, x = child_age), position = ggplot2::position_jitter(0.2), color = &quot;lightgray&quot; ) + ggplot2::stat_smooth( formula = y ~ x, method = &quot;lm&quot;, se = FALSE, size = 1, linetype = &quot;dashed&quot;, color = &quot;black&quot; ) + ggplot2::geom_point(size = 3) + ggplot2::geom_line(size = 1.5) + ggplot2::xlab(&quot;Child&#39;s Age&quot;) + ggplot2::ylab(&quot;Antisocial Behavior Score&quot;) + ggplot2::ggtitle(&quot;Sample Mean Trajectories by Sex&quot;) + ggplot2::scale_color_viridis_d(name = &quot;Sex&quot;, option = &quot;C&quot;, end = 0.75) + ggplot2::theme( axis.text.x = ggplot2::element_text( margin = ggplot2::margin(t = 0, r = 0, b = 10, l = 0) ), axis.title.y = ggplot2::element_text( margin = ggplot2::margin(t = 0, r = 10, b = 0, l = 0) ), legend.position = &quot;none&quot; ) + ggplot2::facet_wrap(dplyr::vars(assigned_sex)) ## Warning: Removed 249 rows containing non-finite values (stat_smooth). ## Warning: Removed 249 rows containing missing values (geom_point). ## Warning: Removed 249 rows containing missing values (geom_point). ## Warning: Removed 249 row(s) containing missing values (geom_path). 3.4.2 Individual Plot Second, we plot the anti-social behavior trajectories of a random sample of 12 children. The plots are color-coded based on the child’s assigned sex. # set seed set.seed(654) # randomly select individuals (ids) from dat_final sample_id &lt;- dat_final %&gt;% dplyr::distinct(., person_id) %&gt;% dplyr::sample_n(., size = 12) %&gt;% unlist(.) # filter dat_final by sampled ids and save plot dat_final %&gt;% dplyr::filter(., person_id %in% sample_id) %&gt;% ggplot2::ggplot(.) + ggplot2::aes( y = anti_score, x = child_age, group = person_id, color = assigned_sex ) + ggplot2::geom_smooth( lwd = 0.75, method = &quot;lm&quot;, se = FALSE, linetype = &quot;dashed&quot;, color = &quot;black&quot; ) + ggplot2::geom_point(size = 2) + ggplot2::geom_line(lwd = 1) + ggplot2::xlab(&quot;Child&#39;s Age&quot;) + ggplot2::ylab(&quot;Antisocial Behavior Score&quot;) + ggplot2::ggtitle(&quot;Individual Trajectories Plot&quot;) + ggplot2::scale_color_viridis_d(name = &quot;Sex&quot;, option = &quot;C&quot;, end = 0.75) + ggplot2::theme( axis.text.x = ggplot2::element_text( margin = ggplot2::margin(t = 0, r = 0, b = 10, l = 0) ), axis.title.y = ggplot2::element_text( margin = ggplot2::margin(t = 0, r = 10, b = 0, l = 0) ), legend.position = &quot;bottom&quot;) + ggplot2::facet_wrap(dplyr::vars(person_id)) ## `geom_smooth()` using formula &#39;y ~ x&#39; ## Warning: Removed 9 rows containing non-finite values (stat_smooth). ## Warning: Removed 9 rows containing missing values (geom_point). ## Warning: Removed 9 row(s) containing missing values (geom_path). ## geom_path: Each group consists of only one observation. Do you need to adjust ## the group aesthetic? "],
["4-model-fitting.html", "Part 4 Model Fitting", " Part 4 Model Fitting In the next section, we demonstrate the model-building process for mixed-effects models, including basic model comparisons. After fitting each of these models, we demonstrate how to summarize the global fit comparisons using the gt table package to help us identify our best “semi-unconditional” (that is, without predictors but including the time effects) model. Once we have selected a semi-unconditional model, we add predictors to the model. In this analysis, we are interested in whether the trajectory of anti-social behavior is significantly impacted by a child’s assigned sex after controlling for reading score, mom’s age, home emotional stimulation, and home cognitive stimulation, which have been standardized. Last, we demonstrate how to summarize the model parameter estimates using the gt table package. Modeling Tips: Use “na.action = na.exclude” to allow for easier post-model evaluation when dataset contains missing data. Include “control = list(maxIter = 100, returnObject = TRUE)” to facilitate model convergence. Especially with larger sample sizes, use maximum likelihood estimation (method = “ML”) rather than restricted maximum likelihood during model building; switch to restricted maximum likelihood for the final model. The first argument of nlme::lme gives the structure of the fixed effects, the “random =” argument gives the structure of the random effects. The “weights =” argument specifies the structure of the level-1 error variances; the “correlation =” argument specifies the structure of the level-1 error covariances. "],
["4-1-unconditional.html", "4.1 Unconditional", " 4.1 Unconditional In this set of code, we use the nlme::lme function to find the “best” random effects and variance/covariance structure for modeling our anti-social behavior scores over time. While there is a growing interest in the R community in writing functions to draw statistical modeling packages into the tidyverse (see Tidymodels), wrappers for the older nlme package, authored by José Pinheiro and Douglas Bates for the S and S-PLUS languages originally, have received less attention. In other words, the output of these functions is a little hairy. The helper package broom.mixed is built for “tidying” the output of statistical packages and has some methods built for lme objects (that is, the result of the nlme::lme function). We will use the broom.mixed package along with the anova function from the built-in stats package to do the heavy lifting of displaying model results and model comparisons. (Note: broom.mixed also has a function for extracting tidy global model fit statistics – broom.mixed::glance – but it is just as easy to tidy up the results from the anova function.) 4.1.1 Intraclass Correlation Before we start modeling, a common approach in mixed effects models is to calculate the ICC, or intra-class correlation coefficient. This coefficient falls between 0 and 1 and tells us the proportion of variance in the intercept that exists at level 2 relative to the total variance in the model. In a longitudinal analysis, the ICC is sometimes a contentious statistic to calculate. Because longitudinal models include some time effect, different viewpoints exist as to whether to include the time effect in the model used to estimate the ICC. We will follow recommendations by Lesa Hoffman (2015) to estimate the ICC based on the model with no predictors and without the time effect. Hoffman, L. (2015). Longitudinal analysis: Modeling within-person fluctuation and change. Routledge. Following this method, the estimated intercept for this model yields the grand mean of all of the children’s mean anti-social behavior scores. In other words, if we calculated an average anti-social score for each child across all of their measurements and then averaged those averages, we would be pretty close to the estimated intercept for the null_icc model. In that case, the interpretation of the ICC is the amount of variability in the person-average anti-social scores. A large ICC (closer to 1) would tell us that there is substantial variability in the average anti-social score across children; a smaller ICC (closer to 0) would tell us that children are similar in average anti-social behavior score. ##--MODEL FITTING--## # unconditional (null) model null_icc &lt;- dat_final %&gt;% nlme::lme( anti_score ~ 1, data = ., na.action = na.exclude, method = &quot;ML&quot;, random = ~ 1 | person_id, control = list(maxIter = 100, returnObject = TRUE) ) # calculate the ICC null_icc %&gt;% calc_icc(.) ## [1] 0.4784052 4.1.2 Unconditional Fits To select our “best” semi-unconditional model, we proceed as follows: We start with a fully unconditional, intercept-only model (null_icc). Then, we add a fixed effect for our time variable, child’s age (null_fslp). Next, we add a random effect for the slope of the time variable (null_rslp). Retaining the fixed and random effects for time, we then explore heterogeneous error variance structure (null_hvar). Keeping the fixed and random effects for time but removing the heterogeneous error variances, we explore compound symmetric error covariance structure (null_csym). Our model building strategy was largely guided by the information we gained from exploratory data analysis. First, we assumed a linear trajectory for the outcome over time in null_fslp based on the plots created in Trajectories. Noting the wide variability in slopes and intercepts in the spaghetti plots helped us choose to add a random effect for our time variable to the model in null_rslp. In addition, by calculating the variances and correlations across ages in Univariate Descriptives and Bivariate Descriptives, respectively, we were able to make better decisions about how to model the error variance/covariance structure. Knowing that the variances increased slightly though remained fairly similar across age groups, we decided to try out a heterogeneous error variance structure in null_hvar using the weights = nlme::varIdent() argument. In addition, the pattern of correlations across ages suggested that a compound symmetric error structure might improve our model fit, which we added to the null_csym model using the correlation = nlme::corCompSymm argument. # unconditional model with fixed slope for time var null_fslp &lt;- dat_final %&gt;% nlme::lme( anti_score ~ 1 + child_age, data = ., na.action = na.exclude, method = &quot;ML&quot;, random = ~ 1 | person_id, control = list(maxIter = 100, returnObject = TRUE) ) # unconditional model with random slope for time var null_rslp &lt;- dat_final %&gt;% nlme::lme( anti_score ~ 1 + child_age, data = ., na.action = na.exclude, method = &quot;ML&quot;, random = ~ 1 + child_age | person_id, control = list(maxIter = 100, returnObject = TRUE) ) # unconditional model with heterogeneous variances null_hvar &lt;- dat_final %&gt;% nlme::lme( anti_score ~ 1 + child_age, data = ., na.action = na.exclude, method = &quot;ML&quot;, random = ~ 1 + child_age | person_id, weights = nlme::varIdent(form = ~ 1 | child_age), control = list(maxIter = 100, returnObject = TRUE) ) # unconditional model with ar1 error covariance null_csym &lt;- dat_final %&gt;% nlme::lme( anti_score ~ 1 + child_age, data = ., na.action = na.exclude, method = &quot;ML&quot;, random = ~ 1 + child_age | person_id, correlation = nlme::corCompSymm( value = -.3, form = ~ 1 + child_age | person_id ), control = list(maxIter = 100, returnObject = TRUE) ) # example of the raw results from the nlme::lme package null_csym %&gt;% summary(.) ## Linear mixed-effects model fit by maximum likelihood ## Data: . ## AIC BIC logLik ## 5206.916 5243.314 -2596.458 ## ## Random effects: ## Formula: ~1 + child_age | person_id ## Structure: General positive-definite, Log-Cholesky parametrization ## StdDev Corr ## (Intercept) 1.1145000 (Intr) ## child_age 0.1463466 -0.316 ## Residual 1.1692363 ## ## Correlation Structure: Compound symmetry ## Formula: ~1 + child_age | person_id ## Parameter estimate(s): ## Rho ## -0.2888797 ## Fixed effects: anti_score ~ 1 + child_age ## Value Std.Error DF t-value p-value ## (Intercept) 1.2067309 0.16699428 941 7.226181 0 ## child_age 0.0729982 0.01779365 941 4.102486 0 ## Correlation: ## (Intr) ## child_age -0.893 ## ## Standardized Within-Group Residuals: ## Min Q1 Med Q3 Max ## -3.7925762 -0.5524850 -0.1116229 0.5110598 4.2607661 ## ## Number of Observations: 1339 ## Number of Groups: 397 4.1.3 Global Comparisons Table Using the anova function and gt package, we can built a display-quality table of global model fit statistics. As recommended in the ITEMS modules, we use the information criteria to compare non-nested models and models with different random effects structures. The “best” model, and the one we will move forward with when adding covariates in the next section, is the one with the lowest AIC and BIC (in this case, the null_rslp model with a random effect for time, homogenous error variances, and independent error covariance structure). All models are estimated with maximum likelihood during the model-building phase. # comparing models gt_global_tab &lt;- anova(null_icc, null_fslp, null_rslp, null_hvar, null_csym) %&gt;% tibble::as_tibble(.) %&gt;% dplyr::mutate( Name = dplyr::case_when( Model == 1 ~ &quot;Intercept-Only&quot;, Model == 2 ~ &quot;Time (Fixed)&quot;, Model == 3 ~ &quot;Time (Fixed and Random)&quot;, Model == 4 ~ &quot;Heterogeneous Variances&quot;, Model == 5 ~ &quot;Compound Symmetry&quot; ), AIC = round(AIC, 2), BIC = round(BIC, 2) ) %&gt;% dplyr::select(., Model, Name, df, AIC, BIC) %&gt;% gt::gt(.) %&gt;% gt::tab_header( data = ., title = &quot;Global Model Comparisons&quot;, subtitle = &quot;Semi-unconditional models with fixed and random effects for time.&quot; ) %&gt;% gt::tab_spanner( data = ., label = &quot;Model Fit&quot;, columns = c(&quot;df&quot;, &quot;AIC&quot;, &quot;BIC&quot;) ) %&gt;% gt::tab_options( data = ., row.striping.include_table_body = FALSE ) %&gt;% gt::tab_style( data = ., style = gt::cell_borders( sides = c(&quot;top&quot;, &quot;bottom&quot;), color = &quot;#ffffff&quot;, weight = gt::px(0), style = &quot;solid&quot; ), locations = gt::cells_body( columns = dplyr::everything(), rows = dplyr::everything() ) ) %&gt;% gt::cols_align( data = ., align = &quot;center&quot;, columns = c(&quot;Model&quot;, &quot;df&quot;, &quot;AIC&quot;, &quot;BIC&quot;) ) %&gt;% gt::cols_align(., align = &quot;left&quot;, columns = &quot;Name&quot;) %&gt;% gt::tab_footnote( data = ., footnote = paste( &quot;Models 4 &amp; 5 retain the fixed and random effects for time;&quot;, &quot;Model 4 does not contain compound symmetric covariance structure;&quot;, &quot;Model 5 does not contain heterogeneous variances.&quot; ), locations = gt::cells_column_labels(columns = dplyr::vars(Name))) %&gt;% gt::tab_footnote( data = ., footnote = &quot;df = Model degrees of freedom.&quot;, locations = gt::cells_column_labels(columns = dplyr::vars(df)) ) # print plot gt_global_tab html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #yigrsktgxg .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #yigrsktgxg .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #yigrsktgxg .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #yigrsktgxg .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #yigrsktgxg .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #yigrsktgxg .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #yigrsktgxg .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #yigrsktgxg .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #yigrsktgxg .gt_column_spanner_outer:first-child { padding-left: 0; } #yigrsktgxg .gt_column_spanner_outer:last-child { padding-right: 0; } #yigrsktgxg .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #yigrsktgxg .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #yigrsktgxg .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #yigrsktgxg .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #yigrsktgxg .gt_from_md > :first-child { margin-top: 0; } #yigrsktgxg .gt_from_md > :last-child { margin-bottom: 0; } #yigrsktgxg .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #yigrsktgxg .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #yigrsktgxg .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #yigrsktgxg .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #yigrsktgxg .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #yigrsktgxg .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #yigrsktgxg .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #yigrsktgxg .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #yigrsktgxg .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #yigrsktgxg .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #yigrsktgxg .gt_sourcenote { font-size: 90%; padding: 4px; } #yigrsktgxg .gt_left { text-align: left; } #yigrsktgxg .gt_center { text-align: center; } #yigrsktgxg .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #yigrsktgxg .gt_font_normal { font-weight: normal; } #yigrsktgxg .gt_font_bold { font-weight: bold; } #yigrsktgxg .gt_font_italic { font-style: italic; } #yigrsktgxg .gt_super { font-size: 65%; } #yigrsktgxg .gt_footnote_marks { font-style: italic; font-size: 65%; } Global Model Comparisons Semi-unconditional models with fixed and random effects for time. Model Name1 Model Fit df2 AIC BIC 1 Intercept-Only 3 5254.55 5270.15 2 Time (Fixed) 4 5239.87 5260.66 3 Time (Fixed and Random) 6 5204.92 5236.11 4 Heterogeneous Variances 14 5214.20 5286.99 5 Compound Symmetry 7 5206.92 5243.31 1 Models 4 &amp; 5 retain the fixed and random effects for time; Model 4 does not contain compound symmetric covariance structure; Model 5 does not contain heterogeneous variances. 2 df = Model degrees of freedom. "],
["4-2-conditional.html", "4.2 Conditional", " 4.2 Conditional In this section of code, we add our predictor of interest, assigned_sex, and a slate of standardized covariates to the baseline “best” model identified in the step above: null_rslp. If we wanted to conduct further model comparisons for the covariates (e.g., testing the addition of random slopes for the predictors), we could proceed as we did in the section above. Once we have selected our final model, cond_reml, we switch the estimation to restricted maximum likelihood (method = &quot;REML&quot;). 4.2.1 Conditional Fits Let’s add predictors to the linear mixed-effects model with random slope for child_age. The effects of read_score, mom_age, home_emo, and home_cog have been standardized for the purposes of interpretation. # conditional model cond_full &lt;- dat_final %&gt;% nlme::lme( anti_score ~ 1 + child_age + assigned_sex + scale(read_score) + scale(mom_age) + scale(home_emo) + scale(home_cog), data = ., na.action = na.exclude, method = &quot;ML&quot;, random = ~ 1 + child_age | person_id, control = list(maxIter = 100, returnObject = TRUE) ) # final model fit with REML cond_reml &lt;- dat_final %&gt;% nlme::lme( anti_score ~ 1 + child_age + assigned_sex + scale(read_score) + scale(mom_age) + scale(home_emo) + scale(home_cog), data = ., na.action = na.exclude, method = &quot;REML&quot;, random = ~ 1 + child_age | person_id, control = list(maxIter = 100, returnObject = TRUE) ) # example of raw output cond_reml %&gt;% summary(.) ## Linear mixed-effects model fit by REML ## Data: . ## AIC BIC logLik ## 4877.071 4933.642 -2427.535 ## ## Random effects: ## Formula: ~1 + child_age | person_id ## Structure: General positive-definite, Log-Cholesky parametrization ## StdDev Corr ## (Intercept) 0.6102073 (Intr) ## child_age 0.1278017 -0.329 ## Residual 1.3217583 ## ## Fixed effects: anti_score ~ 1 + child_age + assigned_sex + scale(read_score) + scale(mom_age) + scale(home_emo) + scale(home_cog) ## Value Std.Error DF t-value p-value ## (Intercept) 0.3045651 0.3178177 873 0.958301 0.3382 ## child_age 0.1186889 0.0324837 873 3.653794 0.0003 ## assigned_sexmale 0.8790356 0.1386554 392 6.339712 0.0000 ## scale(read_score) -0.1453568 0.0863945 873 -1.682477 0.0928 ## scale(mom_age) -0.1049835 0.0719887 392 -1.458332 0.1455 ## scale(home_emo) -0.3439285 0.0731898 392 -4.699129 0.0000 ## scale(home_cog) -0.1250640 0.0725356 392 -1.724174 0.0855 ## Correlation: ## (Intr) chld_g assgn_ scl(r_) scl(m_) scl(hm_m) ## child_age -0.950 ## assigned_sexmale -0.177 -0.044 ## scale(read_score) 0.825 -0.836 0.053 ## scale(mom_age) -0.033 0.069 -0.158 -0.090 ## scale(home_emo) -0.032 0.039 -0.036 -0.039 -0.148 ## scale(home_cog) -0.069 0.055 0.077 -0.071 -0.185 -0.270 ## ## Standardized Within-Group Residuals: ## Min Q1 Med Q3 Max ## -3.0993649 -0.5663559 -0.1545480 0.4730016 3.9019146 ## ## Number of Observations: 1272 ## Number of Groups: 397 4.2.2 Parameter Estimates Table Now, we create a table of parameter estimates for the final model (cond_reml), grouped by fixed and random effects (note that we have opted to remove p-values from our table and instead included lower and upper bounds of the 95% confidence interval): # table results gt_results_tab &lt;- cond_reml %&gt;% broom.mixed::tidy(., conf.int = TRUE) %&gt;% dplyr::select( -tidyselect::any_of(c(&quot;effect&quot;, &quot;group&quot;, &quot;df&quot;, &quot;statistic&quot;, &quot;p.value&quot;)) ) %&gt;% dplyr::mutate(., dplyr::across(where(is.numeric), ~round(., 2))) %&gt;% dplyr::rename( Parameter = term, Estimate = estimate, SE = std.error, CI_low = conf.low, CI_high = conf.high) %&gt;% dplyr::mutate( Parameter = dplyr::case_when( Parameter == &quot;child_age&quot; ~ &quot;Child Age&quot;, Parameter == &quot;assigned_sexmale&quot; ~ &quot;Male&quot;, Parameter == &quot;scale(read_score)&quot; ~ &quot;Reading Score (std.)&quot;, Parameter == &quot;scale(mom_age)&quot; ~ &quot;Mother&#39;s Age (std.)&quot;, Parameter == &quot;scale(home_emo)&quot; ~ &quot;Home Emotional Stimulation (std.)&quot;, Parameter == &quot;scale(home_cog)&quot; ~ &quot;Home Cognitive Stimulation (std.)&quot;, Parameter == &quot;sd_(Intercept)&quot; ~ &quot;Std. Dev. (Intercept)&quot;, Parameter == &quot;cor_child_age.(Intercept)&quot; ~ &quot;Corr. (Intercept. with Child Age)&quot;, Parameter == &quot;sd_child_age&quot; ~ &quot;Std. Dev. (Child Age)&quot;, Parameter == &quot;sd_Observation&quot; ~ &quot;Std. Dev. (Residual)&quot;, TRUE ~ Parameter ) ) %&gt;% gt::gt(.) %&gt;% gt::tab_header( data = ., title = &quot;Model Results&quot;, subtitle = &quot;Conditional model with homogenous variances and independent error covariance.&quot; ) %&gt;% gt::tab_spanner( data = ., label = &quot;Model Estimates&quot;, columns = c(&quot;Estimate&quot;, &quot;SE&quot;, &quot;CI_low&quot;, &quot;CI_high&quot;) ) %&gt;% gt::tab_options(., row.striping.include_table_body = FALSE) %&gt;% gt::tab_style( data = ., style = gt::cell_borders( sides = c(&quot;top&quot;, &quot;bottom&quot;), color = &quot;#ffffff&quot;, weight = gt::px(0), style = &quot;solid&quot; ), locations = gt::cells_body( columns = dplyr::everything(), rows = dplyr::everything() ) ) %&gt;% gt::cols_label(., CI_low = &quot;CI (2.5%)&quot;, CI_high = &quot;CI (97.5%)&quot;) %&gt;% gt::cols_align( data = ., align = &quot;center&quot;, columns = c(&quot;Estimate&quot;, &quot;SE&quot;, &quot;CI_low&quot;, &quot;CI_high&quot;) ) %&gt;% gt::cols_align(., align = &quot;left&quot;, columns = &quot;Parameter&quot;) %&gt;% gt::tab_row_group(., group = &quot;Random Effects&quot;, rows = 8:11) %&gt;% gt::tab_row_group(., group = &quot;Fixed Effects&quot;, rows = 1:7) %&gt;% gt::fmt_missing(., columns = 2:5) %&gt;% gt::tab_footnote(data = ., footnote = paste( &quot;(std.) = Covariate has been standardized;&quot;, &quot;Std. Dev. = Estimated standard deviation of the random effect;&quot;, &quot;Corr. = Estimated correlation between level-2 random effects.&quot; ), locations = gt::cells_column_labels(columns = dplyr::vars(Parameter)) ) # print plot gt_results_tab ## Warning in min(rows_matched): no non-missing arguments to min; returning Inf ## Warning in max(rows_matched): no non-missing arguments to max; returning -Inf html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #opfazzmjrx .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #opfazzmjrx .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #opfazzmjrx .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #opfazzmjrx .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #opfazzmjrx .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #opfazzmjrx .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #opfazzmjrx .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #opfazzmjrx .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #opfazzmjrx .gt_column_spanner_outer:first-child { padding-left: 0; } #opfazzmjrx .gt_column_spanner_outer:last-child { padding-right: 0; } #opfazzmjrx .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #opfazzmjrx .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #opfazzmjrx .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #opfazzmjrx .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #opfazzmjrx .gt_from_md > :first-child { margin-top: 0; } #opfazzmjrx .gt_from_md > :last-child { margin-bottom: 0; } #opfazzmjrx .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #opfazzmjrx .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #opfazzmjrx .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #opfazzmjrx .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #opfazzmjrx .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #opfazzmjrx .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #opfazzmjrx .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #opfazzmjrx .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #opfazzmjrx .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #opfazzmjrx .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #opfazzmjrx .gt_sourcenote { font-size: 90%; padding: 4px; } #opfazzmjrx .gt_left { text-align: left; } #opfazzmjrx .gt_center { text-align: center; } #opfazzmjrx .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #opfazzmjrx .gt_font_normal { font-weight: normal; } #opfazzmjrx .gt_font_bold { font-weight: bold; } #opfazzmjrx .gt_font_italic { font-style: italic; } #opfazzmjrx .gt_super { font-size: 65%; } #opfazzmjrx .gt_footnote_marks { font-style: italic; font-size: 65%; } Model Results Conditional model with homogenous variances and independent error covariance. Parameter1 Model Estimates Estimate SE CI (2.5%) CI (97.5%) Fixed Effects (Intercept) 0.30 0.32 -0.32 0.93 Child Age 0.12 0.03 0.05 0.18 Male 0.88 0.14 0.61 1.15 Reading Score (std.) -0.15 0.09 -0.31 0.02 Mother's Age (std.) -0.10 0.07 -0.25 0.04 Home Emotional Stimulation (std.) -0.34 0.07 -0.49 -0.20 Home Cognitive Stimulation (std.) -0.13 0.07 -0.27 0.02 Random Effects Std. Dev. (Intercept) 0.61 &mdash; 0.00 108.24 Corr. (Intercept. with Child Age) -0.33 &mdash; -1.00 0.99 Std. Dev. (Child Age) 0.13 &mdash; 0.04 0.44 Std. Dev. (Residual) 1.32 &mdash; &mdash; &mdash; 1 (std.) = Covariate has been standardized; Std. Dev. = Estimated standard deviation of the random effect; Corr. = Estimated correlation between level-2 random effects. "],
["5-model-diagnostics.html", "Part 5 Model Diagnostics", " Part 5 Model Diagnostics In this section, we demonstrate a few graphical model diagnostic techniques using the level-1 residuals and fitted values as well as the level-2 random effects from our final conditional model, cond_reml. First, we combine the residuals and random effects estimates with the original dataset. Next, we create “base plots”, which include the ggplot2 elements that we will use in each plot. In this case, we split all of our diagnostic plots by levels of child’s assigned sex simply for the purposes of demonstration. Last, we briefly demonstrate graphical diagnostic plots for the following assumptions: normality of residuals and random effects homoskedasticity (constant variance) of residuals across groups independence of level-1 and level-2 errors (level-2 random effects are not assumed independent from each other) For more on assumption checking in mixed-effects models, see Pinheiro, J., &amp; Bates, D. (2006). Mixed-effects models in S and S-PLUS. Springer Science &amp; Business Media. (Note: Pinhero and Bates are also the authors of the nlme package!) "],
["5-1-diagnostics-setup.html", "5.1 Diagnostics Setup", " 5.1 Diagnostics Setup 5.1.1 Merge Data Using the nlme::ranef, fitted, and residuals functions, we can merge our original dataset (dat_final) with the output from our final estimated model, cond_reml. Note that we choose to use standardized residuals by requesting type = &quot;pearson&quot; from the residuals function. Recall that because the dat_final dataset contains missing observations for both the outcome (anti-social behavior) and predictors, we used the na.exclude option when fitting our models in Conditional Fits. If we hadn’t done this, then we would get errors when trying to re-merge the residuals back with the original data. ##--Data Prep--## mod &lt;- cond_reml model_eval &lt;- mod %&gt;% nlme::ranef(., condVar = TRUE) %&gt;% tibble::as_tibble(.) %&gt;% dplyr::mutate( person_id = dat_final %&gt;% dplyr::distinct(., person_id) %&gt;% unlist(.), .before = &quot;(Intercept)&quot; ) %&gt;% dplyr::rename(., resid_int = `(Intercept)`, resid_age = child_age) %&gt;% dplyr::right_join(., dat_final, by = &quot;person_id&quot;) %&gt;% dplyr::mutate( resid_id = residuals(mod, type = &quot;pearson&quot;), fitted_id = fitted(mod) ) 5.1.2 Base Plots To reduce repetition in plotting in the sections below, we create two baseplots for level-1 residual diagnostics and for level-2 random effects diagnostics. These base setups request that the printed plots will all have panels split and colored by child’s assigned sex. ## plot setup g_l1 &lt;- model_eval %&gt;% ggplot2::ggplot(.) + ggplot2::aes(colour = assigned_sex, fill = assigned_sex) + ggplot2::scale_color_viridis_d(name = &quot;Sex&quot;, option = &quot;C&quot;, end = 0.75) + ggplot2::scale_fill_viridis_d(name = &quot;Sex&quot;, option = &quot;C&quot;, end = 0.75) + ggplot2::theme(legend.position = &quot;none&quot;) + ggplot2::facet_wrap(~assigned_sex) g_l2 &lt;- model_eval %&gt;% dplyr::distinct(., person_id, .keep_all = TRUE) %&gt;% ggplot2::ggplot(.) + ggplot2::aes(colour = assigned_sex, fill = assigned_sex) + ggplot2::scale_color_viridis_d(name = &quot;Sex&quot;, option = &quot;C&quot;, end = 0.75) + ggplot2::scale_fill_viridis_d(name = &quot;Sex&quot;, option = &quot;C&quot;, end = 0.75) + ggplot2::theme(legend.position = &quot;none&quot;) + ggplot2::facet_wrap(~assigned_sex) "],
["5-2-normality-plots.html", "5.2 Normality Plots", " 5.2 Normality Plots In this code, we demonstrate how to plot histograms and qq-plots of our residuals and random effects to assess the normality assumption. In our histograms, we should see symmetric residuals centered around 0. The qq-plot helps us see where deviations from normality occur when the dots fail to align with the solid diagonal line. ## Normality of Residuals # level-1 residual histogram g_l1 + ggplot2::aes(x = resid_id) + ggplot2::geom_histogram() + ggplot2::xlab(&quot;Standardized Residual Value&quot;) + ggplot2::ylab(&quot;Frequency&quot;) + ggplot2::ggtitle(&quot;Histogram of Standardized Level-1 Residuals&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 316 rows containing non-finite values (stat_bin). # level-1 qq plot g_l1 + ggplot2::aes(sample = resid_id, colour = assigned_sex) + ggplot2::geom_qq() + ggplot2::geom_qq_line() + ggplot2::xlab(&quot;Theoretical Quantiles&quot;) + ggplot2::ylab(&quot;Sample Quantiles&quot;) + ggplot2::ggtitle(&quot;QQ-Plot of Standardized Level-1 Residuals&quot;) ## Warning: Removed 316 rows containing non-finite values (stat_qq). ## Warning: Removed 316 rows containing non-finite values (stat_qq_line). # level-2 random effect histogram (intercept) g_l2 + ggplot2::aes(x = resid_int) + ggplot2::geom_histogram() + ggplot2::xlab(&quot;Random Effect&quot;) + ggplot2::ylab(&quot;Frequency&quot;) + ggplot2::ggtitle(&quot;Histogram of Level-2 Random Effects (Intercept)&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # level-2 qq plot (intercept) g_l2 + ggplot2::aes(sample = resid_int) + ggplot2::geom_qq() + ggplot2::geom_qq_line() + ggplot2::xlab(&quot;Theoretical Quantiles&quot;) + ggplot2::ylab(&quot;Sample Quantiles&quot;) + ggplot2::ggtitle(&quot;QQ-Plot of Level-2 Random Effects (Intercept)&quot;) # level-2 random effect histogram (random time slope) g_l2 + ggplot2::aes(x = resid_age) + ggplot2::geom_histogram() + ggplot2::xlab(&quot;Random Effect&quot;) + ggplot2::ylab(&quot;Frequency&quot;) + ggplot2::ggtitle(&quot;Histogram of Level-2 Random Effects (Time)&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # level-2 qq plot (random time slope) g_l2 + ggplot2::aes(sample = resid_age) + ggplot2::geom_qq() + ggplot2::geom_qq_line() + ggplot2::xlab(&quot;Theoretical Quantiles&quot;) + ggplot2::ylab(&quot;Sample Quantiles&quot;) + ggplot2::ggtitle(&quot;QQ-Plot of Level-2 Random Effects (Time)&quot;) "],
["5-3-homoskedasticity-plots.html", "5.3 Homoskedasticity Plots", " 5.3 Homoskedasticity Plots The assumption of homoskedasticity for multilevel models states that the level-1 residuals should be centered around 0 for each group (in our case, child), and that the variance of each child’s scores is the same across children. We can assess this both by plotting the residuals against fitted values, looking for points to be randomly distributed across the plot. Using grouped boxplots, we can also check to see whether each person’s box has the same size (because our sample size is large, the “boxes” will appear more like lines). ## Homogeneity of Variance Assumption (Level 1) # level-1 residual x fitted scatterplot g_l1 + ggplot2::aes(x = fitted_id, y = resid_id) + ggplot2::geom_point() + ggplot2::geom_hline(yintercept = 0) + ggplot2::xlab(&quot;Fitted Value&quot;) + ggplot2::ylab(&quot;Standardized Residual&quot;) + ggplot2::ggtitle(&quot;Scatterplot of Fitted Values and Standardized Level-1 Residuals&quot;) ## Warning: Removed 316 rows containing missing values (geom_point). # level-1 group boxplot g_l1 + ggplot2::aes( x = as.factor(person_id), y = resid_id, group = as.factor(person_id) ) + ggplot2::geom_boxplot() + ggplot2::theme( axis.ticks.x = ggplot2::element_blank(), axis.text.x = ggplot2::element_blank() ) + ggplot2::xlab(&quot;Child ID&quot;) + ggplot2::ylab(&quot;Standardized Residual&quot;) + ggplot2::ggtitle(&quot;Grouped Boxplot of Standardized Level-1 Residuals&quot;) ## Warning: Removed 316 rows containing non-finite values (stat_boxplot). "],
["5-4-independence-plots.html", "5.4 Independence Plots", " 5.4 Independence Plots Last, we check the assumption of independence across level-1 and level-2 residuals/random effects. This assumption states that the level-1 residuals should not be related to the level-2 random effects. We assess this using scatter plots. We also plot the level-2 random effects against one another. As shown in our [model results][Assessing Covariate Effects], the correlation between the level-2 intercept random effect and level-2 time random effect is not statistically different from 0, which we can assess visually using this scatter plot. ## Independence of Residuals Assumption # level-1 residuals &amp; level-2 random effects (intercept) g_l1 + ggplot2::aes(x = resid_id, y = resid_int) + ggplot2::geom_point() + ggplot2::xlab(&quot;Standardized Residual&quot;) + ggplot2::ylab(&quot;Random Effect (Intercept)&quot;) + ggplot2::ggtitle(&quot;Scatterplot of Standardized Level-1 Residuals and Level-2 Random Effects&quot;) ## Warning: Removed 316 rows containing missing values (geom_point). ## level-1 residuals &amp; level-2 random effects (random time slope) g_l1 + ggplot2::aes(x = resid_id, y = resid_age) + ggplot2::geom_point() + ggplot2::xlab(&quot;Standardized Residual&quot;) + ggplot2::ylab(&quot;Random Effect (Time)&quot;) + ggplot2::ggtitle(&quot;Scatterplot of Standardized Level-1 Residuals and Level-2 Random Effects&quot;) ## Warning: Removed 316 rows containing missing values (geom_point). ## level-2 random effects (intercept &amp; random time slope) - not independent g_l2 + ggplot2::aes(x = resid_age, y = resid_int) + ggplot2::geom_point() + ggplot2::xlab(&quot;Random Effect (Time)&quot;) + ggplot2::ylab(&quot;Random Effect (Intercept)&quot;) + ggplot2::ggtitle(&quot;Scatterplot of Level-2 Random Effects&quot;) "]
]
